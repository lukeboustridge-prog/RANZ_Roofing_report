---
phase: 08-search-filtering-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/reports/route.ts
  - src/components/reports/ReportSearch.tsx
autonomous: true

must_haves:
  truths:
    - "User can filter the report list by defect severity level and see only matching reports"
    - "User can filter the report list by compliance assessment status (pass/fail/NA)"
    - "User can filter the report list by assigned inspector (admin/reviewer roles only)"
    - "User can filter the report list by date range using any of: creation date, inspection date, submitted date, or approved date"
  artifacts:
    - path: "src/app/api/reports/route.ts"
      provides: "Server-side filter handling for severity, complianceStatus, inspectorId, dateField"
      contains: "severity|complianceStatus|dateField"
    - path: "src/components/reports/ReportSearch.tsx"
      provides: "Four new filter controls in the expanded filter panel"
      contains: "severity|complianceStatus|inspectorId|dateField"
  key_links:
    - from: "src/components/reports/ReportSearch.tsx"
      to: "/api/reports"
      via: "URLSearchParams in fetchReports"
      pattern: "params\\.set.*severity|params\\.set.*complianceStatus|params\\.set.*inspectorId|params\\.set.*dateField"
    - from: "src/app/api/reports/route.ts"
      to: "prisma.report.findMany"
      via: "Prisma where clause with defect relation filter and date field mapping"
      pattern: "where\\.defects.*some.*severity|dateField"
---

<objective>
Add four new filter dimensions to the report list: defect severity, compliance assessment status, assigned inspector, and multi-field date range selection.

Purpose: Inspectors and admins need to efficiently find specific reports among potentially hundreds. Currently they can only filter by status, inspection type, property type, and a single date field. This plan adds the four missing filter criteria required by SRCH-01 through SRCH-04.

Output: Extended GET /api/reports endpoint accepting severity, complianceStatus, inspectorId, and dateField query parameters; extended ReportSearch.tsx with four new filter controls in the collapsible filter panel.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-search-filtering-templates/08-RESEARCH.md
@src/app/api/reports/route.ts
@src/components/reports/ReportSearch.tsx
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GET /api/reports with severity, compliance, inspector, and date field filters</name>
  <files>src/app/api/reports/route.ts</files>
  <action>
  Extend the GET handler in src/app/api/reports/route.ts to support four new query parameters. All changes are within the existing GET function.

  1. **Parse new query params** (after line 49, alongside existing params):
     ```
     const severity = url.searchParams.get("severity");
     const complianceStatus = url.searchParams.get("complianceStatus");
     const dateField = url.searchParams.get("dateField") || "inspectionDate";
     ```
     Note: `inspectorId` is already parsed at line 57 for admin roles.

  2. **Add defect severity filter** (after the propertyType filter block, ~line 105):
     ```typescript
     // Defect severity filter (SRCH-01) - finds reports with at least one defect of this severity
     if (severity) {
       where.defects = {
         some: {
           severity: severity as DefectSeverity
         }
       };
     }
     ```
     Import `DefectSeverity` from `@prisma/client` in the existing import statement on line 8.

  3. **Add compliance status filter** (after severity filter):
     Use post-fetch in-memory filtering because `checklistResults` is nested JSON that cannot be efficiently queried with Prisma JSON filters. The approach:
     - If `complianceStatus` param is present, include `complianceAssessment` in the Prisma query
     - After fetching, filter reports where any checklist item matches the requested status
     - Recalculate totalCount for accurate pagination

     ```typescript
     // Compliance status filter (SRCH-02) - requires post-fetch filtering due to nested JSON
     const needsComplianceFilter = !!complianceStatus;

     // Add complianceAssessment to include if filtering by compliance
     const include = {
       inspector: { select: { id: true, name: true, email: true } },
       _count: { select: { photos: true, defects: true, roofElements: true } },
       ...(needsComplianceFilter ? { complianceAssessment: true } : {}),
     };
     ```

     After the Prisma query, add the post-fetch filter:
     ```typescript
     let filteredReports = reports;
     let filteredCount = totalCount;

     if (complianceStatus && needsComplianceFilter) {
       filteredReports = reports.filter(report => {
         const assessment = (report as any).complianceAssessment;
         if (!assessment?.checklistResults) return false;
         const results = assessment.checklistResults as Record<string, Record<string, string>>;
         for (const checklist of Object.values(results)) {
           for (const status of Object.values(checklist)) {
             if (status === complianceStatus) return true;
           }
         }
         return false;
       });
       filteredCount = filteredReports.length;
     }
     ```

     Use `filteredReports` and `filteredCount` in the response instead of `reports` and `totalCount`. Strip `complianceAssessment` from response to avoid leaking extra data.

  4. **Extend date range filter** (modify existing block at lines 107-116):
     Replace the hardcoded `inspectionDate` filter with a dynamic field selector:
     ```typescript
     if (dateFrom || dateTo) {
       const dateFilter: { gte?: Date; lte?: Date } = {};
       if (dateFrom) dateFilter.gte = new Date(dateFrom);
       if (dateTo) {
         // Set to end of day for inclusive range
         const endDate = new Date(dateTo);
         endDate.setHours(23, 59, 59, 999);
         dateFilter.lte = endDate;
       }

       // Map dateField to correct Prisma field (SRCH-04)
       const validDateFields = ["createdAt", "inspectionDate", "submittedAt", "approvedAt"] as const;
       const selectedField = validDateFields.includes(dateField as any) ? dateField : "inspectionDate";

       if (selectedField === "createdAt") where.createdAt = dateFilter;
       else if (selectedField === "submittedAt") where.submittedAt = dateFilter;
       else if (selectedField === "approvedAt") where.approvedAt = dateFilter;
       else where.inspectionDate = dateFilter;
     }
     ```

  5. **Update response** to include new filter values in the `filters` object:
     ```typescript
     filters: {
       search: search || null,
       status: status || null,
       inspectionType: inspectionType || null,
       propertyType: propertyType || null,
       severity: severity || null,
       complianceStatus: complianceStatus || null,
       dateFrom: dateFrom || null,
       dateTo: dateTo || null,
       dateField: dateField || "inspectionDate",
     },
     ```

  **Important:** Do NOT modify the POST handler. Only modify the GET handler. Keep all existing RBAC logic intact -- the inspectorId filter already correctly restricts non-admin users to their own reports.
  </action>
  <verify>
  Run `npx tsc --noEmit` from the project root to confirm no type errors in the modified file. The build should pass with no new errors (pre-existing errors in validation.test.ts are expected and unrelated).
  </verify>
  <done>
  GET /api/reports accepts `severity`, `complianceStatus`, `inspectorId` (already existed), and `dateField` query parameters. Defect severity uses Prisma relation filter. Compliance status uses post-fetch in-memory filtering. Date range supports createdAt, inspectionDate, submittedAt, and approvedAt fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add severity, compliance, inspector, and date field filter controls to ReportSearch UI</name>
  <files>src/components/reports/ReportSearch.tsx</files>
  <action>
  Extend the ReportSearch component to include four new filter controls. This file is ~804 lines. All changes are additions to existing patterns.

  1. **Extend the SearchFilters interface** (~line 119) to add new fields:
     ```typescript
     interface SearchFilters {
       search: string;
       status: string;
       inspectionType: string;
       propertyType: string;
       dateFrom: string;
       dateTo: string;
       severity: string;           // NEW: DefectSeverity enum value or ""
       complianceStatus: string;   // NEW: "pass"|"fail"|"partial"|"na" or ""
       inspectorId: string;        // NEW: User ID or ""
       dateField: string;          // NEW: "inspectionDate"|"createdAt"|"submittedAt"|"approvedAt"
       sortBy: string;
       sortOrder: "asc" | "desc";
     }
     ```

  2. **Update defaultFilters** (~line 130):
     ```typescript
     const defaultFilters: SearchFilters = {
       search: "",
       status: "",
       inspectionType: "",
       propertyType: "",
       dateFrom: "",
       dateTo: "",
       severity: "",
       complianceStatus: "",
       inspectorId: "",
       dateField: "inspectionDate",
       sortBy: "createdAt",
       sortOrder: "desc",
     };
     ```

  3. **Add severity labels** at the top of the file near other label constants:
     ```typescript
     const severityLabels: Record<string, string> = {
       CRITICAL: "Critical",
       HIGH: "High",
       MEDIUM: "Medium",
       LOW: "Low",
     };

     const complianceStatusLabels: Record<string, string> = {
       pass: "Pass",
       fail: "Fail",
       partial: "Partial",
       na: "N/A",
     };

     const dateFieldLabels: Record<string, string> = {
       inspectionDate: "Inspection Date",
       createdAt: "Created Date",
       submittedAt: "Submitted Date",
       approvedAt: "Approved Date",
     };
     ```

  4. **Add inspector list state and fetch** inside the ReportSearch component, after existing state declarations:
     ```typescript
     const [inspectors, setInspectors] = useState<Array<{ id: string; name: string }>>([]);
     const [userRole, setUserRole] = useState<string>("");
     ```

     Add a useEffect to fetch inspectors for admin users. Use `/api/inspectors` endpoint which already returns `{ id, name }`. Only fetch for admin/reviewer roles:
     ```typescript
     useEffect(() => {
       // Fetch user role and inspector list for admin filter
       async function loadInspectorFilter() {
         try {
           const res = await fetch("/api/inspectors?limit=50");
           if (res.ok) {
             const data = await res.json();
             setInspectors(data.inspectors.map((i: any) => ({ id: i.id, name: i.name })));
             setUserRole("ADMIN"); // If we can fetch inspectors, user has admin access
           }
         } catch {
           // Not admin or fetch failed - inspector filter won't show
         }
       }
       loadInspectorFilter();
     }, []);
     ```

     **Better approach for role detection:** Check if the existing reports response includes inspector data for other users (which it does for admins). Alternatively, simply attempt the fetch -- if it succeeds the user can see the filter. The `/api/inspectors` endpoint is public, so instead use a separate approach: add a small fetch to `/api/reports?limit=1` and check if the response includes other inspectors' reports, OR more simply: just always show the inspector filter and let the server-side RBAC handle it (the API already ignores inspectorId for non-admin users at line 55-64 of route.ts). This is the simplest approach -- show the filter, server ignores it for non-admins.

     **Revised approach (simpler):** Always show the inspector filter dropdown. Populate it from `/api/inspectors?limit=50` which is a public endpoint returning inspector names. The server-side filter in `/api/reports` already enforces RBAC -- non-admin users' requests with inspectorId are silently ignored because `where.inspectorId = user.id` takes precedence.

  5. **Wire new params into fetchReports** (~line 159, in the URLSearchParams building):
     ```typescript
     if (filters.severity) params.set("severity", filters.severity);
     if (filters.complianceStatus) params.set("complianceStatus", filters.complianceStatus);
     if (filters.inspectorId) params.set("inspectorId", filters.inspectorId);
     if (filters.dateField && filters.dateField !== "inspectionDate") {
       params.set("dateField", filters.dateField);
     }
     ```

  6. **Update hasActiveFilters** (~line 213) to include new fields:
     ```typescript
     const hasActiveFilters =
       filters.search ||
       filters.status ||
       filters.inspectionType ||
       filters.propertyType ||
       filters.severity ||
       filters.complianceStatus ||
       filters.inspectorId ||
       filters.dateFrom ||
       filters.dateTo;
     ```

  7. **Add filter controls to the expanded filters panel** (~line 452-543). The existing grid is `sm:grid-cols-2 lg:grid-cols-4`. Change to accommodate more filters. Add a second row of filters below the existing ones. Insert after the existing Property Type filter (before the Date Range section):

     **Severity filter:**
     ```tsx
     <div className="space-y-2">
       <label className="text-sm font-medium">Defect Severity</label>
       <Select value={filters.severity} onValueChange={(v) => updateFilter("severity", v)}>
         <SelectTrigger>
           <SelectValue placeholder="All severities" />
         </SelectTrigger>
         <SelectContent>
           <SelectItem value="">All severities</SelectItem>
           {Object.entries(severityLabels).map(([value, label]) => (
             <SelectItem key={value} value={value}>{label}</SelectItem>
           ))}
         </SelectContent>
       </Select>
     </div>
     ```

     **Compliance status filter:**
     ```tsx
     <div className="space-y-2">
       <label className="text-sm font-medium">Compliance Status</label>
       <Select value={filters.complianceStatus} onValueChange={(v) => updateFilter("complianceStatus", v)}>
         <SelectTrigger>
           <SelectValue placeholder="All statuses" />
         </SelectTrigger>
         <SelectContent>
           <SelectItem value="">All statuses</SelectItem>
           {Object.entries(complianceStatusLabels).map(([value, label]) => (
             <SelectItem key={value} value={value}>{label}</SelectItem>
           ))}
         </SelectContent>
       </Select>
     </div>
     ```

     **Inspector filter:**
     ```tsx
     <div className="space-y-2">
       <label className="text-sm font-medium">Inspector</label>
       <Select value={filters.inspectorId} onValueChange={(v) => updateFilter("inspectorId", v)}>
         <SelectTrigger>
           <SelectValue placeholder="All inspectors" />
         </SelectTrigger>
         <SelectContent>
           <SelectItem value="">All inspectors</SelectItem>
           {inspectors.map((inspector) => (
             <SelectItem key={inspector.id} value={inspector.id}>{inspector.name}</SelectItem>
           ))}
         </SelectContent>
       </Select>
     </div>
     ```

     **Date field selector** (add above the existing date range inputs):
     Replace the existing Date Range section (~lines 514-530) with:
     ```tsx
     <div className="space-y-2">
       <label className="text-sm font-medium">Date Range</label>
       <Select value={filters.dateField} onValueChange={(v) => updateFilter("dateField", v)}>
         <SelectTrigger>
           <SelectValue placeholder="Filter by date..." />
         </SelectTrigger>
         <SelectContent>
           {Object.entries(dateFieldLabels).map(([value, label]) => (
             <SelectItem key={value} value={value}>{label}</SelectItem>
           ))}
         </SelectContent>
       </Select>
       <div className="flex gap-2">
         <Input
           type="date"
           value={filters.dateFrom}
           onChange={(e) => updateFilter("dateFrom", e.target.value)}
           className="flex-1"
         />
         <Input
           type="date"
           value={filters.dateTo}
           onChange={(e) => updateFilter("dateTo", e.target.value)}
           className="flex-1"
         />
       </div>
     </div>
     ```

  8. **Update the grid layout** to accommodate more filters. Change the filter grid from `lg:grid-cols-4` to `lg:grid-cols-4` (keep 4 columns but add a second row). The 7 total filter groups will naturally wrap into 2 rows on large screens (4+3) and stack on mobile.

  **Important notes:**
  - Do NOT restructure the rest of the component. Only add to the filter section.
  - Keep the existing debounced fetch pattern -- the new filters flow through the same mechanism.
  - The export functions should also pass the new filter params (update handleExport to include severity, complianceStatus, inspectorId, dateField in its URLSearchParams).
  </action>
  <verify>
  Run `npx tsc --noEmit` to confirm no type errors. Then run `npm run build` to confirm the page builds successfully.
  </verify>
  <done>
  ReportSearch component displays four new filter controls: defect severity dropdown (Critical/High/Medium/Low), compliance status dropdown (Pass/Fail/Partial/N/A), inspector dropdown (populated from API), and a date field selector above the existing date range inputs. All filters integrate with the existing debounced fetch mechanism and clear when "Clear all filters" is clicked.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new type errors
2. `npm run build` succeeds
3. Filter controls render in the collapsible filter panel
4. Each new filter sends the correct query parameter to GET /api/reports
5. Severity filter returns only reports containing defects with matching severity
6. Compliance filter returns only reports with matching checklist item status
7. Inspector filter is visible to all users but only affects results for admin/reviewer roles (server-side RBAC)
8. Date field selector changes which date column the date range applies to
9. "Clear all filters" resets all new filters to defaults
</verification>

<success_criteria>
- All four SRCH requirements (SRCH-01 through SRCH-04) are satisfied
- TypeScript compiles without errors
- Existing filter functionality (search, status, inspection type, property type) unchanged
- Pagination works correctly with all filter combinations
- RBAC enforcement unchanged -- non-admin users still only see their own reports
</success_criteria>

<output>
After completion, create `.planning/phases/08-search-filtering-templates/08-01-SUMMARY.md`
</output>
