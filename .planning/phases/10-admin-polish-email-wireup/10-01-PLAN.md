---
phase: 10-admin-polish-email-wireup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/email.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Admin edits to email templates in the database affect emails actually sent by the platform"
    - "If the email template service fails, emails still send using the original hardcoded HTML (zero downtime)"
    - "No double-wrapping of RANZ branded header/footer occurs in any email"
  artifacts:
    - path: "src/lib/email.ts"
      provides: "8 email functions with renderTemplate() integration and hardcoded fallback"
      contains: "emailTemplateService.renderTemplate"
  key_links:
    - from: "src/lib/email.ts"
      to: "src/services/email-template-service.ts"
      via: "import emailTemplateService + renderTemplate() calls"
      pattern: "emailTemplateService\\.renderTemplate"
---

<objective>
Wire all 8 email-sending functions in src/lib/email.ts to use `emailTemplateService.renderTemplate()` with fallback to existing hardcoded HTML templates.

Purpose: Admin email template edits in the database currently have no effect on actual emails sent. This plan connects the template service (built in Phase 9) to the email sending functions so admin customisations take effect.

Output: Modified `src/lib/email.ts` where every email function tries the template service first, falls back to the original hardcoded template on failure, and avoids double-wrapping.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-admin-polish-email-wireup/10-RESEARCH.md

Key source files:
@src/lib/email.ts
@src/services/email-template-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire first 4 email functions to template service</name>
  <files>src/lib/email.ts</files>
  <action>
Add import at top of email.ts:
```typescript
import { emailTemplateService } from "@/services/email-template-service";
```

Refactor these 4 functions to use the try/catch renderTemplate pattern:

1. **sendReportSubmittedNotification** (lines 120-146):
   - Build variables: `{ reportNumber, propertyAddress, inspectorName, reportUrl }` from `report` parameter
   - Try `emailTemplateService.renderTemplate("REPORT_SUBMITTED", variables)`
   - Catch: `console.warn("[Email] Template service failed for REPORT_SUBMITTED, using hardcoded fallback:", error instanceof Error ? error.message : error)`
   - Fallback: keep existing `content` variable and `wrapInTemplate(content, ...)` call, assign to `rendered` object with `{ subject, text, html }`
   - Send: use `rendered.subject`, `rendered.text`, `rendered.html` in sendEmail call
   - IMPORTANT: Do NOT call `wrapInTemplate()` on the service result -- renderTemplate() already wraps

2. **sendReportApprovedNotification** (lines 151-181):
   - Variables: `{ reportNumber, propertyAddress, reviewerName, reportUrl }` (note: `reviewerName` comes from the function parameter)
   - Template type: `"REPORT_APPROVED"`
   - Same try/catch/fallback pattern

3. **sendRevisionRequiredNotification** (lines 186-245):
   - Variables: `{ reportNumber, propertyAddress, reviewerName, reportUrl, criticalCount: .toString(), issueCount: .toString(), noteCount: .toString(), suggestionCount: .toString(), totalComments: totalComments.toString() }`
   - Template type: `"REVISION_REQUIRED"`
   - Keep the existing `commentList` HTML construction and full content block as the fallback
   - Convert all numeric counts to strings before passing to renderTemplate

4. **sendNewCommentsNotification** (lines 250-276):
   - Variables: `{ reportNumber, propertyAddress, reviewerName, commentCount: newCommentCount.toString(), reportUrl }`
   - Template type: `"NEW_COMMENTS"`
   - Same pattern

For each function the structure is:
```typescript
// Build variables
const variables = { ... };

// Try template service first
let rendered: { subject: string; html: string; text: string };
try {
  rendered = await emailTemplateService.renderTemplate("TYPE", variables);
} catch (error) {
  console.warn("[Email] Template service failed for TYPE, using hardcoded fallback:", error instanceof Error ? error.message : error);
  // Original hardcoded template (keep existing code)
  const content = `...existing HTML...`;
  rendered = {
    subject: `...existing subject...`,
    text: `...existing text...`,
    html: wrapInTemplate(content, "...existing title..."),
  };
}

return sendEmail({
  to: recipientEmail,
  subject: rendered.subject,
  text: rendered.text,
  html: rendered.html,
});
```

Keep the `wrapInTemplate` function in email.ts -- it is still used by the fallback paths.
  </action>
  <verify>Run `npx tsc --noEmit` from project root. No new type errors in email.ts. Grep for `emailTemplateService.renderTemplate` -- should appear 4 times.</verify>
  <done>sendReportSubmittedNotification, sendReportApprovedNotification, sendRevisionRequiredNotification, and sendNewCommentsNotification all try renderTemplate() first with correct template types and variable mappings, falling back to original hardcoded templates on failure.</done>
</task>

<task type="auto">
  <name>Task 2: Wire remaining 4 email functions to template service</name>
  <files>src/lib/email.ts</files>
  <action>
Continue refactoring the remaining 4 functions in email.ts using the same try/catch pattern:

5. **sendReportFinalizedNotification** (lines 281-346):
   - This function is SPECIAL: it sends TWO emails (inspector + optional client).
   - For the INSPECTOR email:
     - Variables: `{ reportNumber, propertyAddress, inspectorName, inspectorEmail, reportUrl }` from `report` parameter
     - Template type: `"REPORT_FINALIZED"`
     - The try/catch/fallback wraps the inspector email block
   - For the CLIENT email (lines 317-343):
     - This is NOT a named template type in the service. Keep this email hardcoded as-is (no template service call). It uses `wrapInTemplate` directly. Leave the client email block unchanged.
   - The function returns `SendResult[]` -- preserve this contract.

6. **sendReportRejectedNotification** (lines 351-387):
   - Variables: `{ reportNumber, propertyAddress, reviewerName, reason, reportUrl }` (note: `reviewerName` maps to the function parameter `reviewerName`)
   - Template type: `"REPORT_REJECTED"`
   - Same try/catch/fallback pattern

7. **sendAssignmentConfirmationEmail** (lines 417-449):
   - Variables: `{ clientName, propertyAddress, requestType: details.requestType.replace(/_/g, " "), urgency, scheduledDate: details.scheduledDate || "", inspectorName }`
   - Template type: `"ASSIGNMENT_CONFIRMATION"`
   - IMPORTANT: Transform `requestType` with `.replace(/_/g, " ")` BEFORE passing to renderTemplate (the `requestTypeFormatted` variable already exists -- use it)
   - Handle optional `scheduledDate` with `|| ""`

8. **sendInspectorAssignmentEmail** (lines 454-485):
   - Variables: `{ inspectorName, clientName, clientEmail, propertyAddress, requestType: details.requestType.replace(/_/g, " "), urgency, scheduledDate: details.scheduledDate || "", notes: details.notes || "", assignmentUrl }`
   - Template type: `"INSPECTOR_ASSIGNMENT"`
   - Transform `requestType` same as above
   - Handle optional `scheduledDate` and `notes` with `|| ""`

After all 8 functions are wired, verify the import of `emailTemplateService` is at the top and used consistently.
  </action>
  <verify>Run `npx tsc --noEmit` from project root -- zero new errors. Grep for `emailTemplateService.renderTemplate` in email.ts -- should appear 8 times total (once per function, noting sendReportFinalizedNotification only does it for the inspector email). Grep for `wrapInTemplate` -- should still appear in fallback paths AND the client email in sendReportFinalizedNotification.</verify>
  <done>All 8 email functions use emailTemplateService.renderTemplate() with correct template type strings and variable mappings. Fallbacks preserve original hardcoded HTML. No double-wrapping. Optional fields handled with empty string defaults. Enum values transformed before passing to service. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors in email.ts or anywhere caused by changes
2. Grep `emailTemplateService.renderTemplate` in email.ts returns 8 matches
3. Grep `wrapInTemplate` in email.ts returns matches only in fallback paths + client email in sendReportFinalizedNotification
4. No import of `wrapInTemplate` from email-template-service.ts (email.ts has its own copy)
5. All template type strings match exactly: REPORT_SUBMITTED, REPORT_APPROVED, REVISION_REQUIRED, NEW_COMMENTS, REPORT_FINALIZED, REPORT_REJECTED, ASSIGNMENT_CONFIRMATION, INSPECTOR_ASSIGNMENT
</verification>

<success_criteria>
- All 8 email functions try emailTemplateService.renderTemplate() before falling back to hardcoded HTML
- Template type strings and variable names match the email-template-service.ts mapping exactly
- No double-wrapping: renderTemplate() result is used directly, wrapInTemplate() only in fallbacks
- Optional variables (scheduledDate, notes) default to empty string
- Enum values (requestType) transformed with .replace(/_/g, " ") before passing to service
- TypeScript compiles with zero new errors
- sendReportFinalizedNotification client email remains hardcoded (no template type for it)
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-polish-email-wireup/10-01-SUMMARY.md`
</output>
