---
phase: 07-notifications-sharing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/reports/[id]/review/route.ts
  - src/app/shared/[token]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Inspector receives an in-app + push notification when their report is approved, rejected, or has revision requested"
    - "Inspector receives an email when their report review decision is made"
    - "Shared report with password shows ONLY the password form until correct password is entered"
    - "Shared report without password loads report content directly"
    - "Notification failures do not break review decision submission"
  artifacts:
    - path: "src/app/api/reports/[id]/review/route.ts"
      provides: "Review decision endpoint with notification triggers"
      contains: "createAndPushNotification"
    - path: "src/app/shared/[token]/page.tsx"
      provides: "Password-gated shared report page"
      contains: "requiresPassword"
  key_links:
    - from: "src/app/api/reports/[id]/review/route.ts"
      to: "src/lib/notifications/push-service.ts"
      via: "createAndPushNotification import and call"
      pattern: "createAndPushNotification\\(report\\.inspector"
    - from: "src/app/api/reports/[id]/review/route.ts"
      to: "src/lib/email.ts"
      via: "email template function calls"
      pattern: "send.*Notification|send.*Email"
    - from: "src/app/shared/[token]/page.tsx"
      to: "/api/shared/[token]"
      via: "fetch call with password parameter"
      pattern: "fetch.*api/shared.*password"
---

<objective>
Wire notification triggers into the review decision endpoint so inspectors are notified of review outcomes, and verify shared report password protection enforces content hiding until correct password is entered.

Purpose: Completes NOTIF-03 (web push notifications for review status changes) and SHARE-01 (password protection enforcement on shared reports).
Output: Modified review route with notification triggers; verified shared report password gate.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-notifications-sharing/07-RESEARCH.md

Key source files:
@src/app/api/reports/[id]/review/route.ts
@src/app/shared/[token]/page.tsx
@src/app/api/shared/[token]/route.ts
@src/lib/notifications/push-service.ts
@src/lib/email.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire notification triggers into review decision endpoint</name>
  <files>src/app/api/reports/[id]/review/route.ts</files>
  <action>
Modify the PATCH handler in src/app/api/reports/[id]/review/route.ts to add notification triggers AFTER the review decision is recorded (after the audit log creation on line ~362, before the return statement on line ~383).

Add these imports at the top of the file:
```typescript
import { createAndPushNotification } from "@/lib/notifications/push-service";
import {
  sendReportApprovedNotification,
  sendRevisionRequiredNotification,
  sendReportRejectedNotification,
} from "@/lib/email";
```

After the review comment creation block (after the `if (comment)` block ending around line 374) and BEFORE the response message building, add notification logic:

```typescript
// --- Notify inspector of review decision ---
const baseUrl = process.env.NEXT_PUBLIC_APP_URL || "https://reports.ranz.org.nz";

if (report.inspector?.id) {
  // 1. In-app + push notification (for all decisions)
  const notificationTypeMap: Record<string, import("@prisma/client").NotificationType> = {
    APPROVE: "REPORT_APPROVED",
    REJECT: "REPORT_REJECTED",
    REQUEST_REVISION: "REPORT_COMMENTS",
  };

  const notificationTitleMap: Record<string, string> = {
    APPROVE: "Report Approved",
    REJECT: "Report Rejected",
    REQUEST_REVISION: "Revision Required",
  };

  const notificationMessageMap: Record<string, string> = {
    APPROVE: `Report ${report.reportNumber} has been approved by ${user.name}`,
    REJECT: `Report ${report.reportNumber} has been rejected by ${user.name}`,
    REQUEST_REVISION: `Report ${report.reportNumber} requires revision - feedback from ${user.name}`,
  };

  createAndPushNotification(report.inspector.id, {
    type: notificationTypeMap[decision],
    title: notificationTitleMap[decision],
    message: notificationMessageMap[decision],
    link: `/reports/${id}`,
    reportId: id,
    metadata: {
      decision,
      reviewerName: user.name,
    },
  }).catch(err => {
    console.error("[Review] Failed to send in-app notification:", err);
  });

  // 2. Email notification (decision-specific template)
  if (report.inspector.email) {
    const reportInfo = {
      reportNumber: report.reportNumber || "",
      propertyAddress: report.propertyAddress || "",
      inspectorName: report.inspector.name || "",
      inspectorEmail: report.inspector.email,
      reportUrl: `${baseUrl}/reports/${id}`,
    };

    if (decision === "APPROVE") {
      sendReportApprovedNotification(reportInfo, user.name || "Reviewer").catch(err => {
        console.error("[Review] Failed to send approval email:", err);
      });
    } else if (decision === "REQUEST_REVISION") {
      // Build comment summary from the current review comment
      const commentsSummary = {
        critical: 0,
        issue: decision === "REQUEST_REVISION" ? 1 : 0,
        note: 0,
        suggestion: 0,
      };
      sendRevisionRequiredNotification(reportInfo, user.name || "Reviewer", commentsSummary).catch(err => {
        console.error("[Review] Failed to send revision email:", err);
      });
    } else if (decision === "REJECT") {
      sendReportRejectedNotification(reportInfo, user.name || "Reviewer", comment || "No reason provided").catch(err => {
        console.error("[Review] Failed to send rejection email:", err);
      });
    }
  }
}
```

IMPORTANT:
- All notification calls use .catch() and are NOT awaited (fire-and-forget pattern matching existing codebase conventions)
- The notification type must use valid NotificationType enum values from @prisma/client (REPORT_APPROVED, REPORT_REJECTED, REPORT_COMMENTS are all valid enum values)
- Do NOT modify the POST handler (start review) or GET handler
- Do NOT change the review decision logic, audit log creation, or response format
- The report variable already includes inspector with { id, name, email } from the existing include query
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- no type errors. Grep src/app/api/reports/[id]/review/route.ts for:
- "createAndPushNotification" (must appear)
- "sendReportApprovedNotification" (must appear in import and call)
- "sendRevisionRequiredNotification" (must appear in import and call)
- "sendReportRejectedNotification" (must appear in import and call)
- ".catch" (must appear 4 times: 1 for push + 3 for email branches)
  </verify>
  <done>
PATCH /api/reports/[id]/review triggers: (1) in-app + push notification to inspector for all decisions, (2) decision-specific email to inspector (approved/revision/rejected). All calls are non-blocking with .catch().
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify and harden shared report password protection</name>
  <files>src/app/shared/[token]/page.tsx</files>
  <action>
Review the shared report page at src/app/shared/[token]/page.tsx and verify the password protection flow. Based on the current code analysis, the flow ALREADY works correctly:

1. Initial fetch (no password) -> API returns 401 with { requiresPassword: true } -> page shows PasswordForm
2. User enters password -> re-fetch with ?password=xyz -> API verifies hash -> returns report data
3. Page only renders report content AFTER data is received (line 226: `if (!data) return null`)

The password protection is ALREADY properly enforced at both the API level (returns 401 without password) and UI level (shows password form, does not render content until authenticated). The initial fetch on mount always goes to the API first, and the API never returns report data without password verification.

However, there is one UX hardening to add -- show an error message if the user enters the wrong password. Currently when the password is wrong, the API returns 401 with { requiresPassword: true, error: "Invalid password" }, but the page just re-renders the password form without showing the error.

Update the fetchReport function to capture and display the password error:
1. Inside the `if (result.requiresPassword)` block (around line 138-141), add a check: if `pwd` was provided (meaning this was a password submission, not the initial check), set an error state for the password form
2. Add a `passwordError` state: `const [passwordError, setPasswordError] = useState("");`
3. In the requiresPassword block of fetchReport: `if (pwd) { setPasswordError("Invalid password. Please try again."); }` and `else { setPasswordError(""); }`
4. Clear passwordError at the start of fetchReport: add `setPasswordError("")` after `setError("")`
5. In the password form JSX (inside the `if (requiresPassword)` return), add an error message between the form title and password input:
```tsx
{passwordError && (
  <p className="text-sm text-destructive text-center">{passwordError}</p>
)}
```

This is a small UX improvement that makes the password protection feel complete. Do NOT change:
- The fetch logic (GET with query param)
- The API route (already correct)
- The initial loading/error states
- The report content rendering
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- no type errors. Visually inspect src/app/shared/[token]/page.tsx to confirm:
1. passwordError state exists
2. Error message is displayed in the password form
3. Report content is only rendered after data is set (the `if (!data) return null` guard remains)
4. Password form is the ONLY thing shown when requiresPassword is true
  </verify>
  <done>
Shared report password protection is verified and hardened: (1) API returns 401 without valid password, (2) page shows only password form until authenticated, (3) wrong password shows error message, (4) report content never leaks before password verification.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. Review decision endpoint sends in-app + push + email notifications for APPROVE, REJECT, and REQUEST_REVISION decisions
3. All notification calls use .catch() pattern (non-blocking)
4. Review decision still returns correct response with success message (unchanged response format)
5. Shared report page shows password form for password-protected links
6. Shared report page shows "Invalid password" feedback on wrong password
7. Report content is never rendered before password verification succeeds
</verification>

<success_criteria>
- NOTIF-03: Review decisions (approve/reject/revision) trigger in-app notification + push to inspector AND decision-specific email
- SHARE-01: Password-protected shared reports show only the password form until correct password is entered; wrong password shows error feedback
- All notification calls are fire-and-forget with .catch() error handling
- No regressions: review workflow still works, shared reports still accessible, TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/07-notifications-sharing/07-02-SUMMARY.md`
</output>
