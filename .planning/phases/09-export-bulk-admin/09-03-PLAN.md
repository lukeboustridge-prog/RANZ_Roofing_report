---
phase: 09-export-bulk-admin
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/services/email-template-service.ts
  - src/app/api/admin/email-templates/route.ts
  - src/app/api/admin/email-templates/[id]/route.ts
  - src/app/api/admin/email-templates/seed/route.ts
autonomous: true

must_haves:
  truths:
    - "EmailTemplate model exists in Prisma schema with type, subject, bodyHtml, bodyText, variables, and isActive fields"
    - "Email template service renders templates with {{variable}} substitution and falls back to hardcoded templates"
    - "Admin can list, view, update, and preview email templates via API"
    - "Seed endpoint populates default templates from existing hardcoded email functions"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "EmailTemplate model definition"
      contains: "model EmailTemplate"
    - path: "src/services/email-template-service.ts"
      provides: "Template rendering with variable substitution and fallback"
      min_lines: 80
    - path: "src/app/api/admin/email-templates/route.ts"
      provides: "GET (list) and POST (create) endpoints for email templates"
      exports: ["GET", "POST"]
    - path: "src/app/api/admin/email-templates/[id]/route.ts"
      provides: "GET (detail), PUT (update) endpoints for individual templates"
      exports: ["GET", "PUT"]
  key_links:
    - from: "src/services/email-template-service.ts"
      to: "prisma.emailTemplate"
      via: "database query for template by type"
      pattern: "emailTemplate\\.findUnique"
    - from: "src/services/email-template-service.ts"
      to: "src/lib/email.ts"
      via: "fallback to hardcoded templates when DB template not found"
      pattern: "getDefaultTemplate|fallback"
---

<objective>
Create the email template database model, rendering service, and CRUD API endpoints for admin email template management.

Purpose: Admins need to customize email notification content without code changes. This creates the backend infrastructure: Prisma model, template rendering service with variable substitution, and API routes for template management.
Output: EmailTemplate model, rendering service, seed endpoint, and CRUD API routes.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files
@prisma/schema.prisma                            # Current schema to add EmailTemplate model
@src/lib/email.ts                                 # Existing hardcoded email templates to extract defaults from
@src/app/api/admin/reports/batch/route.ts          # Admin API auth pattern reference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EmailTemplate model and create template service</name>
  <files>
    prisma/schema.prisma
    src/services/email-template-service.ts
  </files>
  <action>
    **1. Add EmailTemplate model to `prisma/schema.prisma`**

    Add at the end of the schema (before any closing comments):

    ```prisma
    model EmailTemplate {
      id        String   @id @default(cuid())
      type      String   @unique  // "REPORT_SUBMITTED", "REPORT_APPROVED", "REVISION_REQUIRED", "REPORT_REJECTED", "REPORT_FINALIZED", "ASSIGNMENT_CONFIRMATION", "INSPECTOR_ASSIGNMENT", "NEW_COMMENTS"
      name      String             // Human-readable name: "Report Approved Notification"
      subject   String             // Email subject with {{variable}} placeholders
      bodyHtml  String   @db.Text  // HTML body with {{variable}} placeholders
      bodyText  String   @db.Text  // Plain text body with {{variable}} placeholders
      variables Json               // Schema of available variables: { "reportNumber": "string", "propertyAddress": "string" }
      isActive  Boolean  @default(true)
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt
    }
    ```

    Run `npx prisma db push` to apply (NOT migrate, since this is a development workflow matching existing patterns).

    **2. Create `src/services/email-template-service.ts`**

    Create a service with:

    a. `renderTemplate(templateType: string, variables: Record<string, string>)`:
       - Look up template from DB by type where isActive=true
       - If found: substitute all `{{key}}` placeholders in subject, bodyHtml, bodyText with values from variables map
       - If NOT found: fall back to default hardcoded templates (extract the existing HTML from `src/lib/email.ts` functions)
       - Return `{ subject: string, html: string, text: string }`

    b. `getDefaultTemplates()`:
       - Return an array of default template objects matching the 8 email types currently in `src/lib/email.ts`:
         1. REPORT_SUBMITTED - variables: reportNumber, propertyAddress, inspectorName, reportUrl
         2. REPORT_APPROVED - variables: reportNumber, propertyAddress, reviewerName, reportUrl
         3. REVISION_REQUIRED - variables: reportNumber, propertyAddress, reviewerName, reportUrl, criticalCount, issueCount, noteCount, suggestionCount, totalComments
         4. REPORT_REJECTED - variables: reportNumber, propertyAddress, reviewerName, reason, reportUrl
         5. REPORT_FINALIZED - variables: reportNumber, propertyAddress, inspectorName, inspectorEmail, reportUrl
         6. ASSIGNMENT_CONFIRMATION - variables: clientName, propertyAddress, requestType, urgency, scheduledDate, inspectorName
         7. INSPECTOR_ASSIGNMENT - variables: inspectorName, clientName, clientEmail, propertyAddress, requestType, urgency, scheduledDate, notes, assignmentUrl
         8. NEW_COMMENTS - variables: reportNumber, propertyAddress, reviewerName, commentCount, reportUrl
       - Each default template contains the subject, HTML body, and plain text extracted from the corresponding function in `src/lib/email.ts`, but with values replaced by `{{variableName}}` placeholders

    c. `substituteVariables(template: string, variables: Record<string, string>)`:
       - Private helper that does `replaceAll("{{key}}", value)` for each entry
       - Handle missing variables gracefully (leave placeholder as-is rather than crash)

    d. `previewTemplate(templateType: string, sampleData?: Record<string, string>)`:
       - Render a template with sample/example data for admin preview
       - Use sensible sample data if none provided (e.g., reportNumber: "RANZ-2025-001234")

    Export a singleton instance: `export const emailTemplateService = new EmailTemplateService();`
  </action>
  <verify>
    - `npx prisma db push` succeeds (or `npx prisma generate` at minimum)
    - `npx tsc --noEmit` passes
    - EmailTemplate model exists in schema.prisma
    - email-template-service.ts exports EmailTemplateService with renderTemplate method
    - Service has fallback logic when DB template not found
  </verify>
  <done>
    EmailTemplate model exists in database. Template service renders templates with variable substitution and falls back to hardcoded defaults from email.ts when no DB template exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create email template CRUD API routes and seed endpoint</name>
  <files>
    src/app/api/admin/email-templates/route.ts
    src/app/api/admin/email-templates/[id]/route.ts
    src/app/api/admin/email-templates/seed/route.ts
  </files>
  <action>
    Create admin-only API routes for email template management. Use the same auth pattern as `src/app/api/admin/reports/batch/route.ts` (getAuthUser + role check for ADMIN/SUPER_ADMIN).

    **1. `src/app/api/admin/email-templates/route.ts`**

    - GET: List all email templates ordered by type. Return array of templates with all fields.
    - POST: Create a new email template. Accept `{ type, name, subject, bodyHtml, bodyText, variables }`. Validate type is unique. Return created template.

    **2. `src/app/api/admin/email-templates/[id]/route.ts`**

    - GET: Get a single template by ID. Return template with all fields.
    - PUT: Update a template. Accept partial body (subject, bodyHtml, bodyText, isActive). Return updated template. Do NOT allow changing `type` (it's the unique identifier). Validate that bodyHtml contains all required variables listed in the template's `variables` field (warn if missing, don't block).

    **3. `src/app/api/admin/email-templates/seed/route.ts`**

    - POST: Seed default templates from the hardcoded email functions. Use `emailTemplateService.getDefaultTemplates()` to get the defaults. Use `prisma.emailTemplate.upsert` for each template (upsert on type) so it's idempotent. Return `{ seeded: number, skipped: number }`.
    - This is a one-time setup endpoint that populates the database with the current hardcoded templates so admins can then customize them.

    All endpoints: return proper HTTP status codes (200, 201, 400, 401, 403, 404, 500). Include error messages in response body.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All three route files exist with correct exports
    - Routes require ADMIN/SUPER_ADMIN auth
    - Seed endpoint uses upsert for idempotency
    - CRUD operations cover list, get, create, update
  </verify>
  <done>
    Admin can list all email templates, view individual templates, update template content, and seed defaults from hardcoded templates. All endpoints are admin-protected.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma generate` succeeds with new EmailTemplate model
2. `npx tsc --noEmit` passes
3. EmailTemplate model in schema.prisma has type (unique), subject, bodyHtml, bodyText, variables, isActive
4. Email template service has renderTemplate with DB lookup + fallback
5. CRUD routes exist: list, get, create, update, seed
6. All routes require ADMIN/SUPER_ADMIN auth
</verification>

<success_criteria>
- EmailTemplate model exists in Prisma schema with all required fields
- Template service renders with {{variable}} substitution
- Service falls back to hardcoded templates when DB template not found
- Admin can list, view, create, and update templates via API
- Seed endpoint populates 8 default templates from existing email.ts functions
- All endpoints are admin-protected
</success_criteria>

<output>
After completion, create `.planning/phases/09-export-bulk-admin/09-03-SUMMARY.md`
</output>
